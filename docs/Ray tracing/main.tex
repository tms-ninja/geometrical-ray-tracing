\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{datetime}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{tikz}

\usepackage{listings}  % For nicely displaying Python code
\usepackage{xcolor}
\definecolor{keywords}{RGB}{255,0,90}
\definecolor{comments}{RGB}{0,150,0}
\definecolor{black}{RGB}{0,0,0}
\definecolor{green}{RGB}{0,171,46}
\definecolor{purple}{RGB}{125,17,23}
\definecolor{orange}{RGB}{240,109,18}
\definecolor{blue}{RGB}{17,38,208}
\definecolor{red}{RGB}{191,3,20}

% Redefining vectors and define unit vectors
\let\vec \bm
\newcommand{\uveci}{{\bm{\hat{\textnormal{\bfseries\i}}}}}
\newcommand{\uvecj}{{\bm{\hat{\textnormal{\bfseries\j}}}}}
\DeclareRobustCommand{\uvec}[1]{{%
  \ifcsname uvec#1\endcsname
     \csname uvec#1\endcsname
   \else
    \bm{\hat{\mathbf{#1}}}%
   \fi
}}

% differential operator
\newcommand{\diff}{\textnormal{d}}

% remove math formatting
\newcommand{\mrm}[1]{\mathrm{#1}}


\title{Ray tracing}
\author{Tom Spencer}
\date{\currenttime, \today}

\begin{document}

\lstset{language=Python, 
        basicstyle=\ttfamily\small, 
        morekeywords={self},
        keywordstyle=\color{orange},
        commentstyle=\color{red},
        stringstyle=\color{green},
        showstringspaces=false,
        identifierstyle=\color{black},
}

\maketitle

\section{Introduction}
Aiming to make a program for tracing light rays through various optical components such as lenses, prisms and mirrors. Hope to implement it in Python first, then re-implement it in C++ and finally get Python running it in C++ (might need to use Cython or C to do this).

It allows me to explore various object orientated programming concepts in C++ such as polymorphism and virtual functions.

\section{Program implementation}
We define a base component class called \texttt{component} from which each type of component derives. E.g. we have derived classes including \texttt{mirror} and \texttt{lens}. The base class declares the methods \texttt{hit\_test()} which tests if a light ray interacts with the component and \texttt{hit()}, which performs the interaction. In Python we also have a \texttt{plot()} method that plots the component to the current plot.

All components present in an optical system are simply stored in a Python list.

\subsection{C++ complications}
In C++ there isn't a simple way of storing all our components in a list like container such as \texttt{std::vector} as all elements must be of the same type. Without cheating and using something like \texttt{boost::any}, this can be overcome by making use of polymorphism.

Any sort of component (such as a mirror or lens) is described by a class (\texttt{Mirror} and \texttt{Lens}) that derives from a \texttt{Component} base class. The \texttt{Component} class defines the \texttt{hit\_test()} and \texttt{hit()} methods as virtual functions. These are then overridden in the derived classes.

C++ allows us to create a pointer \texttt{ptr} of type \texttt{\textsuperscript{*}Component} to a derived class such as \texttt{Mirror}. Suppose \texttt{ptr} points at an instance of \texttt{Mirror}. Since \texttt{hit()} is a virtual finction, when we call it using \texttt{ptr->hit()}, the \texttt{hit()} method in the \texttt{Mirror} class is called. This is because the \texttt{hit()} defined in \texttt{Mirror} is `more derived' than the \texttt{hit()} in \texttt{Component} and when a virtual function is called, the implementation that is executed corresponds to the `most derived.' Equivalently if \texttt{ptr} was pointing at an instance of \texttt{Lens}, it would call the \texttt{hit()} method defined in \texttt{Lens}.

We then store all the components in a \texttt{std::vector} of type \texttt{\textsuperscript{*}Component}. All elements in the vector are then the same type, even though they point to different types of component. To avoid having to manage the memory it would probably be a good idea to use a smart pointer like \texttt{std::unique\_ptr} rather than a raw pointer.

\subsection{Memory structures}
We know now how to store and describe the system of optical components we wish to trace the rays through. Now we need to work out how to structure the rays themselves.

In Python, we used a 3 dimensional \texttt{numpy} array, with the first index identifying the ray, the second the interaction point and the third discriminating x and y coordinate. \texttt{numpy} allows us to easily slice the array to extract specific components. In C++, it doesn't seem we can do this. There would seem to be two options:
\begin{itemize}
    \item Create a class to define a 3d array
    \begin{itemize}
        \item Has the advantage memory is all in one place
        \item Can directly interact with a numpy array when using python
    \end{itemize}
    \item Create a \texttt{Ray} class that contains vectors of x and y coordinates
    \begin{itemize}
        \item Memory is all over the place
        \item Would need to copy everything into a \texttt{numpy} array if we wanted to do that
    \end{itemize}
\end{itemize}
I think it would be easier to create a \texttt{Ray} class to keep track of everything and then wrap it in \texttt{Cython}. Could always add a function to convert it to a \texttt{numpy} array and we're never going to be dealing with large numbers of rays, so memory probably isn't an issue. It also means I just need to pass a reference to the ray to any function and the function can work out get whatever it wants.

I think the best way forward is to create a \texttt{Ray} class, with member variables describing the current direction of the ray as a \texttt{std::array<double, 2>} and the interaction points as a \linebreak {\texttt{std::vector<std::array<double, 2>>}}. This has the benefit that a single mathematical vector is described as a \texttt{std::array<double, 2>}, and this can easily be passed to functions. Also the position data of a single ray is contiguous. All the rays are then stored in a vector.

When initialising the \texttt{Ray} class, we should reserve the memory required for the vector, depending on how many tracings we want to do. When we compute the new position, we can then just \texttt{push\_back} the answer into the vector.

\subsection{Final}
Each ray is described by an instance of a \texttt{Ray} class. This includes:
\begin{itemize}
    \item A \texttt{std::array} used to describe the direction of the ray
    \item A vector of \texttt{std::array} used to describe the initial and interaction points of the ray
\end{itemize}

Each component ultimately derives from the \texttt{Component} class. This declares:
\begin{itemize}
    \item A \texttt{test\_hit()} method that tests whether a ray interacts with the component. Takes a reference to a instance of \texttt{Ray} as an argument. Returns -1.0 if the ray does not interact, otherwise the time to interaction
    \item A \texttt{hit()} method that performs the interaction. Takes a reference to a instance of \texttt{Ray} and maximum number of interactions to perform as arguments. Doesn't return anything, modifies the existing \texttt{Ray} instance.
    \item Several helper functions for performing common tasks:
    \begin{itemize}
        \item Rotate function. Takes a \texttt{std::array<double, 2>} and rotates it by $-\theta$. Equivalent to rotating to a coordinate system rotated by $\theta$
        \item A method \texttt{compute\_t()} which returns the time for a ray to reach a certain position. Assumes the position does lie along the ray's path. Uses the larger of $v_x$ or $v_y$ in magnitude so it so numerically stable.
    \end{itemize}
\end{itemize}
From this three helper classes are derived. These aren't meant to be initialised directly, but help in the construction of classes that are. They are:
\begin{itemize}
    \item \texttt{Plane}
    \begin{itemize}
        \item Describes a simple planar component
        \item Declares \texttt{start} and \texttt{end} member variables to define the start and end points of the plane
        \item Defines a constructor to initialise the class with given start and end points
        \item Implements the \texttt{test\_hit()} method to test for a ray hitting the plane
    \end{itemize}
    \item \texttt{Spherical}
    \begin{itemize}
        \item Describes a circular component or arc
        \item Declares member variables for describing centre of circle/arc, its radius, and start/end angles for defining arc
        \item Defines constructor for these variables
        \item Implements the \texttt{test\_hit()} method to test for a ray hitting the circle/arc
    \end{itemize}
    \item \texttt{Complex\_Component}
    \begin{itemize}
        \item Describes a complex component composed of several other components
        \item Declares a vector of type \texttt{std::unique\_ptr<Component>} to store the sub-components of this component
        \item Implements both the \texttt{test\_hit()} and \texttt{hit()} method:
        \begin{itemize}
            \item For \texttt{test\_hit()}, we simply need to iterate over all the sub-components, return -1.0 if there are no interactions, otherwise the smallest positive time
            \item For \texttt{hit()}, we wish to trace a ray through these sub-components with a maximum number of interactions
            \item This is the same as the original problem, so we can just call the \texttt{trace\_ray()} function that will do this for us
        \end{itemize}
    \end{itemize}
\end{itemize}
From these there are four basic components implemented:
\begin{itemize}
    \item \texttt{Mirror} - plane mirror
    \item \texttt{Mirror\_Sph} - spherical mirror
    \item \texttt{Refract\_Plane} - refraction at a planar boundary
    \item \texttt{Refract\_Sph} - refraction at a spherical boundary
\end{itemize}

Once these basic components have been implemented, complex components such as prisms or lenses should be exceedingly easy to implement. All that would need to be implemented would be a constructor that constructs the sub-components and adds them to the vector of sub-components.

To perform the tracing, there are two relevant functions:
\begin{itemize}
    \item \texttt{trace\_ray()} traces a single ray through a number of components, up to a maximum number of iteration, $n$. Takes a reference to a \texttt{Ray} instance, vector of \texttt{std::unique\_ptr<Component>} and maximum number of iterations as arguments. Works directly on the ray instance
    \item \texttt{trace()} takes a vector of rays and traces them through the components given using \texttt{trace\_ray()}
\end{itemize}

\section{Determining the intersection of a ray with a surface}
We shall always consider the light ray in question to start at $\vec{r}_0 = x_0 \uveci + y_0 \uvecj$ and follow a path,
\begin{equation}
    \vec{r}(t) = \vec{r}_0 + \vec{v}t,
\end{equation}
where $\vec{v}$ is a unit vector indicating the direction of travel. $t$ is a time-like quantity and for an interaction we must have $t > 0$ for the interaction to be in the future. If there are multiple components that could interact we select the one with the smallest $t$.

We first determine expressions for computing where a ray interested with either a planar or spherical surface, since all components possess a combination of planar and spherical surfaces.

\subsection{Ray intersection with a planar surface}
We define a plane as starting at $\vec{r}_1$ and ending at $\vec{r}_2$. It is reflecting on both sides and is described by,
\begin{equation}
    \vec{r}_\mathrm{m}(t')
    =
    \vec{r}_1 + (\vec{r}_2 - \vec{r}_1) t',
\end{equation}
where $0 \le t' \le 1$ for a point to be on the mirror.

We can derive where the ray interests as obeying,
\begin{align}
    t'
    &=
    \frac{v_y(x_1 - x_0) - v_x(y_1 - y_0)}{v_x(y_2 - y_1) - v_y(x_2 - x_1)}, &
    t
    &=
    \frac{x_{0} \left(- y_{1} + y_{2}\right) - x_{1} y_{2} + x_{2} y_{1} + y_{0} \left(x_{1} - x_{2}\right)}{v_{x} \left(y_{1} - y_{2}\right) + v_{y} \left(- x_{1} + x_{2}\right)}
\end{align}
Remember we require both a unique solution for $t$ to exist and $0 \le t' \le 1$ for it to intersect the plane. We have to check the denominator is not zero in both cases.

Furthermore, we define two unit vectors. We define $\vec{\hat{D}}$ as a unit vector pointing along the plane from its start point to its end point,
\begin{equation}
    \vec{\hat{D}}
    =
    \frac{\vec{r}_2 - \vec{r}_1}{|\vec{r}_2 - \vec{r}_1|}.
\end{equation}
From this we define the normal unit vector $\vec{\hat n}$ as,
\begin{equation}
\label{eq:normal_vec_def}
    \vec{\hat n}
    =
    - D_y \uveci + D_x \uvecj,
\end{equation}
where $D_x$ and $D_y$ are the x and y components of $\vec{\hat {D}}$ respectively.

\subsection{Ray intersection with a spherical surface}
We consider a circle with centre $(x_l, y_l)$ and radius $R$. In general, only a portion of its surface is modelled with $\theta_i \le t' \le \theta_f$. Here $t'$ is a parameter in the range $0 \le t' < 2\pi$ that takes the place of the polar angle. Its surface can be described by,
\begin{equation}
    \vec{r}_\mathrm{s}(t')
    =
    (x_l + R\cos t') \uveci
    +
    (y_l + R\sin t') \uvecj.
\end{equation}
This gives us two simultaneous equations, namely,
\begin{align}
    x_0 + v_x t &= x_l + R\cos t' \\
    y_0 + v_y t &= y_l + R\sin t'.
\end{align}
Letting $\Delta x = x_0 - x_l$, $\Delta y = y_0 - y_l$ we get,
\begin{align}
\label{eq:sph_simulataneous_1}
    \Delta x + v_x t &= R\cos t' \\
\label{eq:sph_simulataneous_2}
    \Delta y + v_y t &= R\sin t'.
\end{align}

We can solve for either $t$ or $t'$. Originally we solved for $t'$, but it is more efficient to solve for $t$ instead.

\subsubsection{Solving for $t$}
We can eliminate $t'$ by squaring Eqs.~\ref{eq:sph_simulataneous_1} \& \ref{eq:sph_simulataneous_2}, and utilising $\sin^2 \theta + \cos^2 \theta = 1$. This produces the quadratic,
\begin{align}
    0
    &=
    (v_x^2 + v_y^2)t^2
    +
    2(v_x \Delta x + v_y \Delta y)t
    +
    \Delta x^2 + \Delta y^2 - R^2, \\
    &=
    t^2
    +
    2 \gamma t
    +
    \Delta x^2 + \Delta y^2 - R^2,
\end{align}
where we have uses the fact $\vec{v}$ is normalised and defined $\gamma = v_x \Delta x + v_y \Delta y$. The solutions for $t$ can be found as,
\begin{equation}
    t
    =
    -\gamma
    \pm
    \sqrt{\gamma^2 + R^2 - \Delta x^2 - \Delta y^2}.
\end{equation}
We can the compute the position of intersection, if there is one, and then use \texttt{atan2()} to compute $t'$. Trigonometric functions are only called when the ray has intersections in the future ($t>0$). By comparison, $\arccos$ is called for all possible intersections when solving for $t'$. $\sin$ may also be called there could be spurious $t'$ solutions that don't lie along the ray's path, at least using the method above. This leads to solving for $t$ being a more efficient method.

\subsubsection{Solving for $t'$}
This section is kept for reference with earlier versions of the code. Eliminating $t$ from Eqs.~\ref{eq:sph_simulataneous_1} \& \ref{eq:sph_simulataneous_2} produces,
\begin{equation}
    v_y \Delta x - v_x \Delta y
    =
    R v_y \cos t'
    -
    R v_x \sin t'.
\end{equation}
Defining $\delta= v_x \Delta y - v_y \Delta x$, we can eliminate $\sin t'$,
\begin{align}
    -\left(
        \delta + R v_y \cos t'
    \right)^2
    &=
    R^2 v_x^2 \sin^2 t' \\
    &=
    R^2 v_x^2 (1 - \cos^2 t').
\end{align}
This is a quadratic in $\cos t'$ with coefficients,
\begin{align}
    a
    &=
    R^2 \left( v_x^2 + v_y^2 \right), \\
    b
    &=
    2 R v_y \delta, \\
    c
    &=
    \delta^2 - R^2 v_x^2,
\end{align}
and solutions,
\begin{equation}
    \cos t'
    =
    \frac{1}{R}
    \left(
        -v_y
        \delta
        \pm
        \sqrt{
         \delta^2 
        \left(
            v_y^2 - 1
        \right)
        +
        \left(
            v_x R
        \right)^2
        }
    \right),
\end{equation}
This will generate four solutions; two due to the $\pm$ and a further two since if $t'$ is a solution, then so is $2\pi - t'$. We will need to determine to correct solution for the intersection. The solution we are after, if one exists must satisfy the following conditions:
\begin{itemize}
    \item $\cos t'$ must be in the range $-1 \le \cos t' \le 1$, otherwise the ray never intersects the surface
    \item $t'$ are in the necessary range for the surface, $\theta_i \le t' \le \theta_f$
    \item Determine which solutions are true solutions and lie along the light ray's path
    \item If there are two solutions left, choose the solution with the smaller but non-negative $t$ parameter
\end{itemize}

\section{Components}
We would like to provide implementations for the following components:
\begin{itemize}
    \item Mirrors, plane and spherical
    \item Lenses
    \item Prisms
    \item Absorbing screen
\end{itemize}
We will first provide four basic components from which most other components we might be interested in can be described. These will be two that perform reflection/refraction at a planar surface and two that do the same but at a spherical (circular) surface.

\section{Reflecting basic components}
\subsection{Plane mirrors}
We define a plane mirror as starting at $\vec{r}_1$ and ending at $\vec{r}_2$. It is reflecting on both sides and is described by,
\begin{equation}
    \vec{r}_\mathrm{m}(t')
    =
    \vec{r}_1 + (\vec{r}_2 - \vec{r}_1) t',
\end{equation}
where $0 \le t' \le 1$ for a point to be on the mirror. Once we have determined that a ray will intersect with a plane mirror, we need to determine how the ray will reflect. We can compute the new starting position for the ray using the standard equation describing the ray as we have $t$. To compute the new direction, we have that the angle of incidence is equal to the angle of reflection. We have two methods: the rotation method and vector method. Originally the code used the rotation method and its details are kept for reference. The vector method is now used as it is faster.

\subsubsection{Rotation method}
To find the new velocity, we compute the angle, $\alpha$, the plane makes with the $x$ axis,
\begin{equation}
    \label{eq:plane_angle}
    \tan \alpha
    =
    \frac{y_2 - y_1}{x_2 - x_1}.
\end{equation}

Now we must be careful with the cases of $\alpha = \frac{\pi}{2}, \frac{3\pi}{2}$ since the tangent is infinite in these cases. Moreover as tangent is $\pi$ periodic, $\arctan$ will give the correct answer up to $\pm \pi$. Fortunately \texttt{numpy} has the function \texttt{arctan2(y, x)} which specifically accounts for these two cases, and also will always return the correct sign. In C++, the \texttt{cmath} header provides \texttt{atan2()}.

We can now perform the reflection by rotating our coordinates by $\alpha$ to coordinates $(x', y')$. In these coordinates the ray is normal to the plane so the reflection is then simply a case of negating the $y'$ component. The standard rotation matrix to rotate a point anticlockwise from $(x, y)$ to $x', y')$ by $\theta$ is,
\begin{equation}
    \begin{pmatrix}
        \cos \theta & -\sin \theta \\
        \sin \theta &  \cos \theta
    \end{pmatrix}.
\end{equation}
However, this rotates a point anticlockwise, we want to rotate our coordinates, so we require a minus sign for our matrix,
\begin{equation}
    \label{eq:rotation_matrix}
    R(\theta)
    =
    \begin{pmatrix}
         \cos \theta & \sin \theta \\
        -\sin \theta & \cos \theta
    \end{pmatrix}.
\end{equation}
Once we've negated the $y'$ component, we can then rotate back using $R(-\theta)$ to get the new direction of the ray.

The disadvantage of this method is performance. It involves call to trigonometric functions which are slow, especially \texttt{atan2(y, x)}. Fortunately we can avoid this.

\subsubsection{Vector method}
We don't really need to rotate the plane each time we perform a reflection. All we really want to do is reflect the component of $\vec{v}$. We can make use of $\vec{\hat{D}}$, the normal vector that points along the plane. The normalisation of $\vec{\hat{D}}$ does involve square rooting, but it only needs to be computed once. The component of $\vec{v}$ perpendicular plane is $\vec{v} - (\vec{v} \cdot \vec{\hat{D}}) \vec{\hat{D}}$ and so the reflections ca be performed as,
\begin{equation}
    \vec{v}
    \rightarrow
    (\vec{v} \cdot \vec{\hat{D}}) \vec{\hat{D}} - \vec{v}.
\end{equation}
We could use $\vec{\hat{n}}$ instead and derive a similar formula.

A disadvantage of this method is $|\vec{v}|$ drifts from 1 over time. As all the maths assumes $|\vec{v}|=1$, this quickly becomes catastrophic after as little as 15-20 interactions. This is easily resolved by re-normalising $\vec{v}$ after each interaction. Since we expect $|v-1| << 1$, we can avoid calls to \texttt{hypot()} by using a Taylor expansion. Denoting $S=v_x^2 + v_y^2$, expanding around $S=1$ produces,
\begin{equation}
    \frac{1}{\sqrt S}
    =
    1
    -\frac{1}{2}(S-1)
    +
    \mathcal{O} \left(
    (S-1)^2
    \right).
\end{equation}
Working to $\mathcal{O} \left(S-1\right)$ should be sufficient.

\subsection{Spherical mirror}
To reflect at a spherical surface, we follow a broadly similar method to that of a planar surface. 

\subsubsection{Old method}
First we determine the $t, t'$ values where the ray intersects the surface. The intersection location is given by,
\begin{align}
    x
    &=
    x_s + R \cos t',
    &
    y
    &=
    y_s + R \sin t',
\end{align}
for a surface with centre $(x_s, y_s)$.

We must then determine the angle $\alpha$ as before. We can easily compute $\alpha$ with the help of a little geometry as we know the angle $t'$ where the intersection occurs. We then have,
\begin{equation}
    \label{eq:alpha_sph}
    \alpha = t' - \frac{\pi}{2}.
\end{equation}

After that it is identical to the plane mirror. We use Eq.~\ref{eq:rotation_matrix} to rotate the axis by $\alpha$, negate the $y'$ component, and finally rotate back to get the new direction.

\subsubsection{New method}
The new method applies a similar method to the vector method for a plane. We use the normal vector of the circle to write the reflections as,
\begin{equation}
    \vec{v}_f 
    =
    \vec{v}_i - 2 (\vec{v}_i \cdot \vec{\hat{n}}) \vec{\hat{n}}.
\end{equation}

\section{Refracting basic components}
Refraction is based on Snell's law, that the angle of incidence, $\theta_i$, and the angle of refraction, $\theta_f$, obey,
\begin{equation}
    n_i \sin \theta_i 
    =
    n_f \sin \theta_f,
\end{equation}
where both angles are measured from the normal of the surface. $n_i$ and $n_f$ are the refractive indices of the initial and final media. A complication of refraction is the possibility of total internal reflection. This occurs when,
\begin{equation}
    \sin \theta_f 
    =
    \frac{n_i \sin \theta_i}{n_f} > 1.
\end{equation}
The value of $\theta_i$ for which $\sin{\theta_f} = 1$ is known as the critical angle. It is,
\begin{equation}
    \theta_c
    =
    \arcsin{\frac{n_f}{n_i}}.
\end{equation}

\subsection{Refraction at a planar surface}
We define the refractive indices as $n_1$ and $n_2$, with $n_1$ on the side $\vec{\hat{n}}$ points towards. In our old method, we rotated our system as it was convenient, though slower. We rotate our coordinates round by $\alpha$ (the angle of the plane) so that the normal lies along the y-axis. We then have,
\begin{equation}
    \theta_i 
    =
    \frac{\pi}{2} - \theta',
\end{equation}
where $\theta'$ is the angle of $\vec{v}'$, that is $\vec v$ in the rotated coordinates. Applying Snell's law to compute $\theta_f$, the new direction of the ray in the rotated coordinates is,
\begin{equation}
    \vec{v}'
    = 
    \cos{
    \left(
        \frac{\pi}{2} - \theta_f
    \right)
    } \uveci'
    +
    \sin{
    \left(
        \frac{\pi}{2} - \theta_f
    \right)
    } \uvecj'.
\end{equation}
Finally we then just have to rotate back to our original coordinates. If total internal reflection is determined to happen, then we simply need to reflect the ray at the point of intersection.

\subsubsection{New method}
The old method calls trigonometric functions including \texttt{sin()} and \texttt{atan2()}. If we were working in three dimensions we could write,
\begin{equation}
\label{eq:refraction_cross_prod}
    n_\mrm{i} \vec{\hat n} \times \vec{v}_\mrm{i} = n_\mrm{f} \vec{\hat n} \times \vec{v}_\mrm{f},
\end{equation}
which produces Snell's law when we take it's magnitude. Working in the xy plane, Eq.~\ref{eq:refraction_cross_prod} produces,
\begin{equation}
    n_\mrm{i} (n_x v_\mrm{iy} - n_y v_\mrm{ix})
    =
    n_\mrm{f} (n_x v_\mrm{fy} - n_y v_\mrm{fx}).
\end{equation}
Imposing the condition $|\vec{v}_\mrm{f}| = 1$ and defining $\gamma = \frac{n_\mrm{i}}{n_\mrm{f}} (n_x v_\mrm{iy} - n_y v_\mrm{ix})$ produces the simultaneous equations,
\begin{align}
    n_x v_\mrm{fy} - n_y v_\mrm{fx}
    &=
    \gamma, \\
    v_\mrm{fx}^2 + v_\mrm{fy}^2 = 1,
\end{align}
which have the solutions,
\begin{align}
\label{eq:refr_v_x}
    v_\mrm{fx} &= -n_y \gamma \pm n_x \sqrt{1-\gamma^2}, \\
\label{eq:refr_v_y}
    v_\mrm{fy} &= n_x \gamma \pm n_y \sqrt{1-\gamma^2}.
\end{align}

Now consider when the discriminant $1 - \gamma^2$ is less than zero. This occurs for $\gamma > 1$ and $\gamma < -1$. Taking the magnitude of Eq.~\ref{eq:refraction_cross_prod}, $\gamma$ can be written in terms of the angle the incident ray makes to the normal of the plane as $\gamma = \frac{n_\mrm{i}}{n_\mrm{f}} \sin \theta$. We therefore do not have a real solution for $\vec{v}_\mrm{f}$ when,
\begin{align}
    \sin \theta > \frac{n_\mrm{f}}{n_\mrm{i}} \quad \mathrm{or} \quad \sin \theta < -\frac{n_\mrm{f}}{n_\mrm{i}}.
\end{align}
This corresponds to total internal reflection occurring. Therefore if the discriminant $1 - \gamma^2 < 0$, we should perform reflection instead of refraction.

Now we determine how to assign $n_\mrm{i}$ and $n_\mrm{f}$ from the $n_1$ and $n_2$ parameters of the plane. The definition of $\vec{\hat{n}}$ in Eq.~\ref{eq:normal_vec_def} means $\vec{\hat{n}}$ points to the `left' of the plane when viewed from its start point towards its end. We can determine which side the ray originates on by considering $\vec{v_\mrm{i}} \cdot \vec{\hat{n}}$,
\begin{align}
    \vec{v_\mrm{i}} \cdot \vec{\hat{n}} 
    &>
    0
    \implies
    n_\mrm{i} = n_2, n_\mrm{f} = n_1, \\
    \vec{v_\mrm{i}} \cdot \vec{\hat{n}} 
    &<
    0
    \implies
    n_\mrm{i} = n_1, n_\mrm{f} = n_2.
\end{align}
This leaves the case of $\vec{v_\mrm{i}} \cdot \vec{\hat{n}} = 0$ where the ray travels along the plane. This should be considered in future.

We must still determine which of the possible solutions in Eqs.~\ref{eq:refr_v_x} \& \ref{eq:refr_v_y} are physical. We start by checking $\vec{v}_\mrm{f}$ is normalised. Taking the same sign produces,
\begin{align}
    |\vec{v}_\mrm{f}|^2
    &=
    (-n_y \gamma \pm n_x \sqrt{1-\gamma^2})^2
    +
    (n_x \gamma \pm n_y \sqrt{1-\gamma^2})^2, \\
    &=
    (n_x^2 + n_y^2)\gamma^2 + (n_x^2 + n_y^2)(1-\gamma^2), \\
    &=
    n_x^2 + n_y^2, \\
    &= 1.
\end{align}
Therefore choosing both positive or both negative will always be correctly normalised. If we choose mixed signs, the result is,
\begin{align}
    |\vec{v}_\mrm{f}|^2
    &=
    (-n_y \gamma \mp n_x \sqrt{1-\gamma^2})^2
    +
    (n_x \gamma \pm n_y \sqrt{1-\gamma^2})^2, \\
    &=
    (n_x^2 + n_y^2)\gamma^2 + (n_x^2 + n_y^2)(1-\gamma^2)
    \pm
    4 n_x n_y \gamma \sqrt{1-\gamma^2}, \\
    &=
    1
    \pm
    4 n_x n_y \gamma \sqrt{1-\gamma^2}.
\end{align}
Choosing mixed solutions is only correctly normalised if the second term is zero. It is zero if $n_x=0$, or $n_y=0$ or $\gamma=1$. These three cases cause the second term in Eqs.~\ref{eq:refr_v_x} \& \ref{eq:refr_v_y} to be zero meaning the mixed sign solutions reduce to the same sign solutions. We do not need to consider these cases any further.

$4 n_x n_y \gamma \sqrt{1-\gamma^2}$ is also zero when $\gamma=0$. Remembering $\gamma = \frac{n_\mrm{i}}{n_\mrm{f}} |\vec{\hat{n}} \times \vec{v}_\mrm{i}|$, $\gamma=0$ implies the ray travels perpendicular to the plane initially and so we must have $\vec{v}_\mrm{f} = \pm \vec{\hat{n}}$. Hence the solution we seek involves either both positive or both negative.

This leaves us with two possible solutions. To distinguish which of the solutions is the one we are after, we note the sign of $\vec{v} \cdot \vec{\hat{D}}$ and $\vec{v} \cdot \vec{\hat{n}}$ must be unchanged after refraction.

\subsection{Refraction at a spherical surface}
At a spherical surface we already have a method for determining where a ray intersects the surface.
\subsubsection{Old method}
The angle we must rotate through is given again by Eq.~\ref{eq:alpha_sph},
\begin{equation}
    \alpha = t' - \frac{\pi}{2}.
\end{equation}
Other than the different equation for computing $\alpha$, the method is very similar to that of a plane.

\subsubsection{New method}
The new method is very similar to that of a plane, but the definitions of $\vec{\hat{n}}$ and $\vec{\hat{D}}$ are different. We take $\vec{\hat{n}}$ to be the `radial' unit vector of the circle. There is no need to call any trigonometric functions as we know the point of intersection, the circle's centre and radius. In order to be consistent with Eq.~\ref{eq:normal_vec_def}, $\vec{\hat{D}}$ must be,
\begin{equation}
    \vec{\hat{D}}
    =
    n_y \uveci
    -
    n_x \uvecj.
\end{equation}

\section{Screen}
We also include a component intended to represent a screen. When a ray hits a screen, we stop tracing it any further. We will implement only a planar screen named \texttt{Screen\_Plane}.

\section{Complex components}
A complex component is one that is composed of other sub-components. These include objects such as lenses and prisms that can be described in terms of basic sub-components or a objects such as system of lenses, which are composed themselves of complex components. Equally, a complex component could be created from a mixture of basic and complex components.

\subsection{Lenses}
We shall first consider a lens to be composed of four components. Two will always be planar boundaries corresponding to the top and bottom planes in Fig.~\ref{fig:convex lens}. The remaining two will be either arcs of planes depending on the type of lens, e.g. biconvex or plano-convex. A generic lens can then be described as a complex component composed of these four objects.

To distinguish between convex, concave and plane lens faces, we take the following convention:
\begin{itemize}
    \item A convex component arc has a \textbf{positive} radius of curvature
    \item A concave component arc has a \textbf{negative} radius of curvature
    \item A plane component arc sets the radius of curvature to be \textbf{zero}
\end{itemize}
This means any radius of curvature where $R < |R_\mathrm{lens}|$ but $R \neq 0$ is invalid. We note we must be careful with how the interior and exterior refractive indices of the lens, $N_\mathrm{in}$ and $n_\mathrm{out}$, correspond to what refractive parameters are passed to each individual component. Changing
a lens arc from convex to concave or swapping from left to right will require care with these refractive parameters.

Note we can compute $\Delta x$ as,
\begin{equation}
    \Delta x = \frac{d}{2} + \sqrt{R^2 - R_\mathrm{lens}^2}.
\end{equation}

Finally we should check for self intersection if one or both of the lens arcs are concave ($R<0$). Strange behaviour might result otherwise.

\begin{figure}
    \centering
    \begin{tikzpicture}
        % Note (0, 2) is where tikz starts drawing the arc
        \draw[thick] (0, 2) arc (150:210:4);
        \draw[thick] (-1.5, 2) arc (30:-30:4);
        \draw[thick] (0, 2) -- (-1.5, 2);
        \draw[thick] (0, -2) -- (-1.5, -2);
        
        \draw[thick, |-|] (-1.5, 2.2) -- (0.0, 2.2) node[pos=0.5, above] {$d$};
        
        % Dashed lines on left & labels
        \draw[thick, dashed]  (-5.37,0) -- (-1.5, 2) -- (-1.5, -2) -- (-5.37,0) -- (-1.5, 0);
        
        \draw[thick, |-|] (-0.75, -2.2) -- (-5.37, -2.2) node[pos=0.5, below] {$\Delta x_1$};
        \draw[thick, |-|] (-1.6, 2.2) -- (-5.47, 0.2) node[pos=0.5, above] {$R_1$};
        
        % Dashed lines on right & labels
        \draw[thick, dashed]  (3.87,0) -- (0, 2) -- (0, -2) -- (3.87,0) -- (0, 0);
        
        \draw[thick, |-|] (-0.75, -2.2) -- (3.97, -2.2) node[pos=0.5, below] {$\Delta x_2$};
        \draw[thick, |-|] (0.1, 2.2) -- (3.97, 0.2) node[pos=0.5, above] {$R_2$};
        
        % R_lens on right
        \draw[thick, |-|] (4.15, 0.0) -- (4.15, -2.2) node[pos=0.5, right] {$R_\mathrm{lens}$};
    \end{tikzpicture}

    \caption{Left: Parameters used to describe a lens, in this case a biconcave. $R_1$ and $R_2$ are the radii of curvature on the left and right sides respectively. $\Delta x_1$ and $\Delta x_2$ give the horizontal offset between the centre of the lens and its respective arc. $R_\mathrm{lens}$ give the radius of the lens and $d$ its thickness.}
    \label{fig:convex lens}
\end{figure}


\section{Calling from Python}
To call from Python we wrap the C++ using Cython. We wrap each C++ class to produce a similarly named class as that in C++ but roughly with "Py" at the front. Class equivalents are detailed in Tab.~\ref{tab:C++ to Cython mappings}. Similarly we also produce a tracing function that takes in Python components and traces them in C++ named \texttt{PyTrace}.

\begin{table}[h!]
\centering
    \begin{tabular}{ |c|c| } 
         \hline
         C++ & Cython \\ 
         \hline
         \texttt{Component} & \texttt{\_PyComponent} \\ 
         \texttt{Complex\_Component} & \texttt{PyComplex\_Complex} \\ 
         \texttt{Plane} & \texttt{\_PyPlane} \\ 
         \texttt{Spherical} & \texttt{\_PySpherical} \\ 
         \texttt{Mirror\_Plane} & \texttt{PyMirror\_Plane} \\ 
         \texttt{Refract\_Plane} & \texttt{PyRefract\_Plane} \\ 
         \texttt{Mirror\_Sph} & \texttt{PyMirror\_Sph} \\ 
         \texttt{Refract\_Sph} & \texttt{PyRefract\_Sph} \\ 
         \texttt{Screen\_Plane} & \texttt{PyScreen\_Plane} \\
         \texttt{Ray} & \texttt{PyRay} \\ 
         \hline
         
    \end{tabular}
    \caption{C++ classes and their equivalent Cython versions.}
    \label{tab:C++ to Cython mappings}
\end{table}

Properties such as the start and end points of planes are exposed as properties. In most cases points are returned as a \texttt{numpy} view. As such they can be edited element wise. The exception to this is \texttt{PyRay.pos} which returns a copy due to the way \texttt{Ray.pos} is stored in C++. Cython classes are initialised using a \texttt{\_\_cinit\_\_()} initialiser. Unfortunately this cannot be overloaded with the current version of Cython, though I do not believe this is an issue.

Furthermore, we have an additional class, \texttt{PyCC\_Wrap}. \texttt{PyCC\_Wrap} is intended to allow easy creation of complex components from Python by simply inheriting from \texttt{PyCC\_Wrap} and passing the Cython components needed to describe the component to the \texttt{PyCC\_Wrap} initialiser. For example, a triangular prism defined through the positions of its vertices and interior/exterior refractive indices can be created using:
\begin{lstlisting}[language=Python]
class Prism(PyCC_Wrap):
    
    def __init__(self, a, b, c, n_in, n_out=1.0):
        comps = [
                PyRefract_Plane(a, b, n_out, n_in),
                PyRefract_Plane(b, c, n_out, n_in),
                PyRefract_Plane(c, a, n_out, n_in)
            ]
            
        # Must remember to call super __init__()
        super().__init__(comps)  
\end{lstlisting}
Like other components, \texttt{PyCC\_Wrap} provides a \texttt{Plot()} method useful for plotting the component.

\end{document}
